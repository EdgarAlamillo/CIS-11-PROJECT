.ORIG x3000

LEA R0, START_MSG
PUTS

START_MSG	.STRINGZ "This program will calculate 5 test scores(0-99 only)"

AND R0, R0, #0


AND R1, R1, #0				;CLEAR R1 FOR LOOP
AND R4, R4, #0				;LOOP COUNTER


;//////////////INPUT/////////////////////

LOOP_START
JSR CLEAR_SCREEN			;CLEAR SCREEN
LEA R0, ASK_MSG				;LOAD ASK MESSAGE TEXT
PUTS						;PRINT

ADD R0, R1, #1				;MOVE R0, R1, #1
JSR DISPLAY_NUM				;DISPLAY NUMBER

LEA R0, COLON_MSG			;A WAY TO RACK THE END OF THE MESSAGE
PUTS


ADD R0, R4, #0				;NUMBER OF DIGITS TO READ
JSR DIG_NUM					;STACK TO NUMBER
JSR DISPLAY_NUM				;DISPLAY NUMBER

GETC						;GET CHARACTER 
ADD R3, R0, x-A				;CHECK FOR ENTER 
BRz NEXT_GRADE				;IF SO THEN NEXT SUBROUTINE 


ADD R3, R4, #-3				;CHECK IF MAX
BRzp LOOP_START 

LD R2, NEG_CHAR_OFF			;CONVERT FROM CHAR TO NUMBER
ADD R0, R0, R2
BRn LOOP_START				;IF NEGATIVE THEN BACK TO LOOP
ADD R2, R3, #-9				;ELSE THEN CHECK IF LAST NUMBER
BRp LOOP_START				;BACK TO START
JSR PUSH					;ELSE THEN PUSH ONTO STACK
ADD R4, R4, #1				;INCRIMENT STACK COUNTER
BRnzp LOOP_START			

NEXT_GRADE					;
ADD R0, R4, #0
JSR DIG_NUM
ADD R3, R0, #0				;MOVE BACK

							
DIGIT_CLEAR					;CLEAR NUMBER
ADD R4, R4, #-1				;CHECK FOR 0
BRn CLEARED
JSR POP						;POP STACK
BRnzp DIGIT_CLEAR

CLEARED
ADD R0, R3, #0
JSR PUSH					;PUSH ONTO STACK
ADD R1, R1, #1		
AND R4, R4, #0				;RESET DIGIT COUNTER
LD R2, LOOP_COUNT
ADD R2, R2, R1
BRn LOOP_START				;IF NEGATIVE BACK TO START

							;ELSE COUNTINUE 
LD R1, STACK_START
LD R2, STACK_SIZE
NOT R2, R2
ADD R2, R2, #1				
AND R3, R3, #0				;STACK COUNTER
ADD R3, R3, #1
AND R5, R5, #0				;AVERAGE COUNTER

LD R4, BASE_MIN				;STACK MIN = 0
ST R4, MIN
LD R4, BASE_MAX
ST R4, MAX
JSR CLEAR_SCREEN

;///////////////////////OUTPUT ALL///////////////////////

OUT_PUT_LOOP
ADD R4, R3, R2				;CHECK TOP OF STACK
BRp ENDOUT_PUT_LOOP

LEA R0, OUTPUT_GRADE
PUTS

ADD R0, R3, #0				
JSR DISPLAY_NUM

LEA R0, COLON_MSG
PUTS

ADD R4, R1, R3
LDR R0, R4, #0				;LOAD R4 INTO R0
JSR DISPLAY_NUM
ADD R4, R0, #0				;STORE R4 INTO R0
LD R0, SPACE				;ADD A SPACE
OUT
ADD R0, R4, #0				
JSR DISPLAY_GRADE			;PRINT GRADE


;///////////////////////MIN CHECK///////////////////

LD R4, MIN					;LOAD MIN LABEL
NOT R4, R4
ADD R4, R4, #1
ADD R4, R4, R0
BRzp NOT_MIN				;IF NOT THEN ONTO NEXT CHECK
ST R0, MIN
NOT_MIN

;///////////////////////MAX CHECK//////////////////

LD R4, MAX					;LOAD MAX LABEL
NOT R4, R4
ADD R4, R4, #1
ADD R4, R4, R0
BRnz NOT_MAX				;IF NOT THEN ONTO AVG
ST R0, MAX
NOT_MAX



ADD R5, R5, R0

ADD R3, R3, #1
LD R0, NEW_LINE				;NEW LINE 
OUT
BRnzp OUT_PUT_LOOP

ENDOUT_PUT_LOOP

LD R0, NEW_LINE
OUT							;NEWLINE THEN END LOOP

;///////////////////////CALCULATE AVERAGE///////////////

LD R1, LOOP_COUNT			;USE LOOP COUNTER FROM BEFORE
NOT R1, R1
ADD R1, R1, #1
ADD R0, R5, #0
JSR DIV
ST R0, AVG					;STORE AVERAGE

;/////////////////DISPLAY TEXT FOR MIN, MAX, AVG//////////////

LEA R0, MIN_TXT				;LOAD MIN TEXT INTO R0 AND PRINT
PUTS
LD R0, MIN
JSR DISPLAY_NUM
ADD R4, R0, #0				
LD R0, SPACE				;ADD A SPACE
OUT
ADD R0, R4, #0				
JSR DISPLAY_GRADE
LD R0, NEW_LINE
OUT							;END OF MIN TEXT PRINT


LEA R0, MAX_TXT				;LOAD MAX TEXT INTO R0 AND PRINT
PUTS
LD R0, MAX
JSR DISPLAY_NUM		
ADD R4, R0, #0				
LD R0, SPACE				;ADD A SPACE
OUT
ADD R0, R4, #0				
JSR DISPLAY_GRADE
LD R0, NEW_LINE
OUT							;END OF MAX TEXT PRINT 


LEA R0, AVG_TXT				;LOAD AVG TXT INTO R0 AND PRINT
PUTS
LD R0, AVG
JSR DISPLAY_NUM
ADD R4, R0, #0				
LD R0, SPACE				;ADD A SPACE
OUT
ADD R0, R4, #0				
JSR DISPLAY_GRADE
LD R0, NEW_LINE
OUT							;END OF AVG TEXT PRINT

HALT

;CONSTANTS - HAVE TO PUT SOME OF THEM HERE OR PROGRAM WILL NOT RUN

ASK_MSG				.STRINGZ "Enter Grade "
COLON_MSG			.STRINGZ ": "
OUTPUT_GRADE		.STRINGZ "Grade "
MIN_TXT				.STRINGZ "Lowest Grade:  "
MAX_TXT				.STRINGZ "Highest Grade: "
AVG_TXT				.STRINGZ "Average Grade: "
CHAR_OFFSET 		.FILL x30
NEG_CHAR_OFF 		.FILL x-30
LOOP_COUNT			.FILL #-5
BASE_MIN			.FILL #10000
BASE_MAX			.FILL #0

;VARIBLES 
MIN					.FILL #0
MAX					.FILL #0
AVG					.FILL #0
	
NEW_LINE				.FILL xA
SPACE				.FILL x20

STACK_SIZE			.FILL x0
STACK_START			.FILL x4000

;/////////////////////MULTIPLICATION/////////////////////////////

MULT1
							;SAVE REGISTERS 
ST R1, REG1
ST R2, REG2
ST R3, REG3
ST R4, REG4
ST R5, REG5
							;RESET REGISTERS 
AND R2, R2, #0				
AND R5, R5, #0				
AND R3, R3, #0				
ADD R3, R3, #1				;RESTART COUNTER


ADD R4, R0, #0
BRzp MULT_INNOT_NEG			;CHECKS FOR NEGATIVE
ADD R5, R5, #1				
NOT R0, R0					
ADD R0, R0, #1
MULT_INNOT_NEG

ADD R4, R1, #0
BRzp MULT_LOOP				
ADD R5, R5, #1				
NOT R1, R1					
ADD R1, R1, #1

;//////////////////////////MAIN LOOP////////////////////

MULT_LOOP

AND R4, R3, R1				
BRz MULT_SKIP_ADD			;SKIP ADDITION 
ADD R2, R0, R2				;ADD R0 TO R2

MULT_SKIP_ADD
ADD R0, R0, R0				
ADD R3, R3, R3				
BRz MULT_END				;END IF R3 = 0
BRnzp MULT_LOOP				;ELSE BACK TO MAIN LOO[]

MULT_END
							
AND R5, R5, #1
BRz MULT_NOT_NEG			;SKIP MULT
NOT R2, R2	
ADD R2, R2, #1
MULT_NOT_NEG

ADD R0, R2, #0				;MOVING R2 TO R0

							;LOAD BACK ORIGINAL REGISTERS 
LD R1, REG1
LD R2, REG2
LD R3, REG3
LD R4, REG4
LD R5, REG5
RET							;RETURN

;///////////////////////DISPLAY NUMBERS SUBROUTINE//////////////////////

DISPLAY_NUM

ST R0, TEMP_R0				;STORE REGISTERS INTO TEMPORARY REGISTERS 
ST R1, TEMP_R1
ST R2, TEMP_R2
ST R3, TEMP_R3
ST R4, TEMP_R4
ST R5, TEMP_R5
ST R6, TEMP_R6
ST R7, TEMP_R7

LD R5, CHAR_OFFSET			;LOAD CHARACTER OFFSET INTO R5
AND R2, R2, #0				
LD R6, NUM10000				
ADD R4, R0, #0

BRzp DISPLAY_NUM_LOOP		;BRANCH IF NEGATIVE 
LD R0, DASH
OUT
NOT R4, R4
ADD R4, R4, #1

DISPLAY_NUM_LOOP
ADD R3, R6, #-1				
BRz DISPLAY_NUM_END			;IF 1 THEN END
ADD R0, R4, #0				;ELSE COUNTINUE 
ADD R1, R6, #0
JSR DIV						
ADD R2, R2, R0				
BRz DISPLAY_NUM_SKIP		
ADD R0, R0, R5				;MOVING THE DIGIT COUNTER
OUT							

DISPLAY_NUM_SKIP
ADD R4, R1, #0				;MOVING R1 TO R4
ADD R0, R6, #0				
AND R1, R1, #0
ADD R1, R1, #10

JSR DIV
ADD R6, R0, #0
BRnzp DISPLAY_NUM_LOOP		;LOOP BACK

DISPLAY_NUM_END
ADD R0, R4, R5				
OUT						
	
LD R0, TEMP_R0				;LOAD BACK THE REGISTERS 
LD R1, TEMP_R1
LD R2, TEMP_R2
LD R3, TEMP_R3
LD R4, TEMP_R4
LD R5, TEMP_R5
LD R6, TEMP_R6
LD R7, TEMP_R7

RET


;///////////////////DIVISION & MODULUS SUBROUTINE////////////////////

DIV
ST R2, REG2					;STORE R2-R4
ST R3, REG3
ST R4, REG4
AND R2, R2, x0				;CLEAR
AND R3, R3, x0				
AND R4, R4, x0				

							;CHECK FOR ZERO
ADD R1, R1, #0
BRnp DIV_NOT_ZERO			;IF NOT SKIP
AND R0, R0, x0
AND R1, R1, x0
BRnzp DIV_END 				
DIV_NOT_ZERO

							;CHECK FOR NEGATIVE
ADD R0, R0, #0
BRzp DIV_NOT_NEG				
ADD R3, R3, #1
NOT R0, R0					
ADD R0, R0, #1
DIV_NOT_NEG

ADD R1, R1, #0
BRnz DIV_NEG				;IF NEGATIVE SKIP
NOT R1, R1					
ADD R1, R1, #1
BRnzp DIV_LOOP
DIV_NEG
ADD R3, R3, #1

DIV_LOOP					
ADD R0, R0, R1				
BRn DIV_END					;IF 0 THEN END
ADD R2, R2, #1				
BRnzp DIV_LOOP				;ELSE LOOP AGAIN

DIV_END
NOT R1, R1					
ADD R1, R1, #1
ADD R4, R1, R0				
AND R3, R3, x1				

BRnz DIV_NEG_PROD			;BEGIN NEGATIVE SUBROUTINE
NOT R2, R2
ADD R2, R2, #1
NOT R4, R4
ADD R4, R4, #1
DIV_NEG_PROD
	

ADD R0, R2, #0
ADD R1, R4, #0

							;LOAD REGISTERS
LD R2, REG2
LD R3, REG3
LD R4, REG4
RET


;//////////////////////PUSH SUBROUTINE////////////////////////



PUSH
ST R1, REG1	
ST R2, REG2

LD R1, STACK_SIZE			;LOAD SIZE LABEL
ADD R1, R1, #1				
ST R1, STACK_SIZE			;STORE STACK SIZE
LD R2, STACK_START			;LOAD START
ADD R1, R1, R2				
STR R0, R1, #0				

LD R1, REG1					;LOAD REGISTERS 
LD R2, REG2 
RET

;//////////////////////////POP SUBROUTINE/////////////////////



POP
ST R1, REG1					;STORE REGISTER LABELS INTO REGISTERS
ST R2, REG2
ST R7, REG7
ST R0, REG0					

LD R0, REG0
POP_SKIP
LD R1, STACK_SIZE			;LOAD SIZE
LD R2, STACK_START			;LOAD START
ADD R1, R1, R2				
LDR R0, R1, #0				
AND R2, R2, #0				
STR R2, R1, #0				
LD R1, STACK_SIZE			;RELOAD SIZE
ADD R1, R1, #-1				
ST R1, STACK_SIZE			;SET SIZE


LD R1, REG1					;LOAD REGISTERS
LD R2, REG2 
LD R7, REG7
RET


;/////////////////////CLEAR SCREEN SUBROUTINE//////////////////



CLEAR_SCREEN
ST R0, REG0					;STORE REGISTER LABELS INTO REGISTERS
ST R1, REG1
ST R7, REG7

LD R0, NEW_LINE
LD R1, CLS_LINES			
		
CLS_LOOP					;CLEAR SCREEN LOOP
OUT
ADD R1, R1, #-1
BRp CLS_LOOP
LD R0, REG0
LD R1, REG1
LD R7, REG7
RET


;//////////////////////////DIGITS TO NUM SUBROUTINE////////////////////

DIG_NUM						;STORE REGISTER LABELS INTO REGISTERS
ST R1, TEMP_R1
ST R2, TEMP_R2
ST R3, TEMP_R3
ST R4, TEMP_R4
ST R5, TEMP_R5
ST R7, TEMP_R7

LD R1, STACK_START			;LOAD STACK START
LD R2, STACK_SIZE			;LOAD SIZE

ADD R3, R1, R2				;GET TOP OF STACK
AND R2, R2, #0				
AND R1, R1, #0				
ADD R1, R1, #1
ADD R4, R0, #0				;LOOP COUNTER

DIG_NUM_LOOP
ADD R4, R4, #-1				
BRn DIG_NUM_END

LDR R0, R3, #0				
JSR MULT1					
ADD R2, R2, R0				;ADD TOTAL

LD R0, NUM10
JSR MULT1					;MULTIPLY
ADD R1, R0, #0

ADD R3, R3, #-1				;DRCEMATE POINTER
BRnzp DIG_NUM_LOOP			;LOOP

DIG_NUM_END
ADD R0, R2, #0				

LD R1, TEMP_R1				;LOAD REGISTERS
LD R2, TEMP_R2
LD R3, TEMP_R3
LD R4, TEMP_R4
LD R5, TEMP_R5
LD R7, TEMP_R7

RET


;/////////////////////DISPLAY GRADE SUBROUTINE///////////////////

DISPLAY_GRADE

ST R0, REG0
ST R1, REG1
ST R7, REG7

LD R1, GRADE_A				;DISPLAY A GRADE
ADD R1, R0, R1
BRn DISPLAY_GRADE_A
LD R0, CHAR_A
OUT
BRnzp DISPLAY_GRADE_END
DISPLAY_GRADE_A

LD R1, GRADE_B				;DISPLAY B GRADE
ADD R1, R0, R1
BRn DISPLAY_GRADE_B
LD R0, CHAR_B
OUT
BRnzp DISPLAY_GRADE_END
DISPLAY_GRADE_B

LD R1, GRADE_C				;DISPLAY C GRADE
ADD R1, R0, R1
BRn DISPLAY_GRADE_C
LD R0, CHAR_C
OUT
BRnzp DISPLAY_GRADE_END
DISPLAY_GRADE_C

LD R1, GRADE_D				;DISPLAY D GRADE
ADD R1, R0, R1
BRn DISPLAY_GRADE_D
LD R0, CHAR_D
OUT
BRnzp DISPLAY_GRADE_END
DISPLAY_GRADE_D


LD R0, CHAR_F				;ELSE F
OUT

DISPLAY_GRADE_END
LD R0, REG0
LD R1, REG1
LD R7, REG7
RET


;///////////////////ALL THE TEMP REGISTERS///////////////////

REG0			.FILL #0
REG1			.FILL #0
REG2			.FILL #0
REG3			.FILL #0
REG4			.FILL #0
REG5			.FILL #0
REG6			.FILL #0
REG7			.FILL #0

TEMP_R0			.FILL #0
TEMP_R1			.FILL #0
TEMP_R2			.FILL #0
TEMP_R3			.FILL #0
TEMP_R4			.FILL #0
TEMP_R5			.FILL #0
TEMP_R6			.FILL #0
TEMP_R7			.FILL #0

;/////////////////////////CONSTANTS///////////////////////////

NUM10000		.FILL #10000	;NUMBERS I NEEDED
NUM10			.FILL #10

CLS_LINES		.FILL #26		;TO CLEAR LINES

GRADE_A			.FILL #-90		;GRADES
GRADE_B			.FILL #-80
GRADE_C			.FILL #-70
GRADE_D			.FILL #-60

CHAR_A			.FILL x41
CHAR_B			.FILL x42
CHAR_C			.FILL x43
CHAR_D			.FILL x44
CHAR_F			.FILL x46

DASH			.FILL x2D


.END